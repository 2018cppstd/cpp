chapter 2 Review _ JR

1. ##### class 내부에서 1개 이상의 static 또는 const 멤버 선언이 가능한지 여부를 조사하고 이유를 서술하시오.

   가능하다.  static 경우는 정적멤버함수를 사용할때  정적멤버변수와 같이 선언할 수 있기 때문이다.  const 경우는 상수변수 선언이기때문에 일반 변수선언과 비슷하기 때문이다.

2. ##### 초기화 섹션을 사용하는 이유에 대해 조사하고 초기화 섹션을 사용할 때와 사용하지 않았을 때의 차이점에 대하여 서술하시오.

   임의의 클래스가 멤버로 다른 객체를 가진다면 초기화 리스트를 사용하지 않은 것보다는 초기화 리스트를 사용한 초기화 방법이 좋다.

   |      | 초기화 섹션 사용X                                            | 초기화 섹션 사용O                          |
   | :--: | ------------------------------------------------------------ | ------------------------------------------ |
   | 코드 | object x;   //디폴트 생성자 호출<br />x=a;    //대입연산자 호출 (두번의 함수 호출) | object x = a;//생성자호출(1번의 함수 호출) |

   초기화 섹션을 사용하지 않았을때는 메모리 공간을 먼저 만들어 지고 만들어진메모리에 대입.

   초기화 섹션을 사용하였을때는 메모리가 만들어 지면서 초기화.

   

3. ##### default 생성자의 동작에 대해 설명하시오.

   다른 생성자가 있는지 확인(있으면 디폴트 생성자는 생성X) → 없으면 컴파일러가 직접(자동으로) 디폴트 생성자 만들어 null or 0  넣어줌( 간혹 쓰레기값이 넣어줄 수 있어서 직접 생성추천) 

   또한, 선언한 객체는 선언한 지역이 끝날 때 메모리를 해제하기 전에 소멸자를 먼저 수행함. 

4. ##### default 복사 생성자의 동작에 대해 설명하시오.

   복사생성자는 기본생성자가 존재하고,  다른객체로부터 값을 복사해서 초기화 하는데 사용.

   ```
   class test{
       public:
       	test(int a): num(a){}
       //   test(const test& te){} 복사생성자 정의
       	~test(){}
       private:
       	int num;
   };
   	test te1(10);
   	test te2 = te1;		//이때 복사생성자가 호출됨.
   ```

   te2를 생성한 다음 te1 멤버 변수를 복사(대입)함.  복사생성자를 선언하지 않았지만 디폴트 복사생성자가 컴파일러의 의해 자동으로 생성됨. 

5. ##### default 소멸자가 존재하는지 조사하고 생성자와 소멸자의 호출관계에 대하여 설명하시오.

   존재한다.   생성자가  호출된 역순으로 소멸자 호출되어 메모리 반환 순서로 소멸. 소멸자를 먼저 호출하는 이유는 메모리가 반환되어질때, 반환되어지지 않은 메모리 공간을 명시적으로 반환해주기 위해서.

6. ##### 깊은복사와 얕은복사에 대해 조사하고 각각의 동작을 예시를 들어 설명하시오.

   얕은 복사는 객체1를 인수로 받아 그 객체의 멤버들을 객체2에다 복사하는것. 하지만, 객체 2선언시 객체1가 복사 된다고 했지만 실제로 메모리를 새로 할당하는것이 아닌, 포인터만 가리키게 즉 참조하기만 함.  먼저 선언된 객체1이 소멸되면서 생성자에서의 메모리를 해제시키고 객체2가 다시 메모리를 해제 시키려면 이미 소멸되었으므로 오류 발생한다.  그래서 깊은 복사를 통해서 복사생성자를 한번더 구현해준다. 멤버뿐 아니라 포인터로 참조하는 대상까지 깊게 복사한다.

7. ##### 복사 생성자가 필요한 이유에 대해 설명하시오.

   생성자가 한번 호출 되고 소멸자가 두번 호출되는 메모리를 할당하는 클래스에는 반드시 복사생성자가 필요하다. 복사생성자가 없으면 멤버대 멤버 복사만 발생하며, 생성자 호출은 되지 않는다. 생성자는 호출되지 않았지만 소멸자는 반드시 호출되기 때문이다. 

   복사생성자가 호출되는 시점은 

   - 객체가 다른객체의 값이 대입될때
   - 객체가 값에 의해 전달될때
   - 객체가 값의 의해 리턴될때 

8. ##### this 포인터에 대해 설명하고 this 포인터를 사용하는 예시를 3가지 이상 작성하시오.

   - this 는 객체 자신에 대한 포인터로서 클래스의 멤버 함수 내에서만 사용된다. this는 객체의 멤버함수가 호출될 때 컴파일러에 의해 보이지 않게 전달되는 객체에 대한 주소이다.  

   - this의 특징

   ​         this는 객체 자신을 가리키는 포인터이다

   ​         객체마다 있다

   ​         클래스의 멤버함수에서만 사용할 수 있다

   ​         static 멤버함수에서는 사용할 수 없다.

   ​         사실 this는 멤버함수에 컴파일러 몰래 삽입한 매개 변수다

   -  멤버 변수의 이름  =  매개 변수 이름

   ```
   circle (int radius){
   	this -> radius = radius; //앞에 있는 radius 는 멤버 radius, 뒤에 radius 는 매개변수 radius}
   ```

   ```
   class X {
   protected:
       int data;
   
   public:
       void Print();
       void Set(int data);
   };
   
   void X::Print() {   //출력을 위한 함수
       cout << "this= " << this << ", data=  " << data << "\n";
   }
   void X::Set(int data) { //protected 변수에 값을 집어넣기 위한 함수
       this->data = data;
   }
   int main(){
   X obj;
       obj.Set(100);
       cout << "obj: ";
       obj.Print();
       cout << "obj의 주소: " << &obj << "\n";
   }
   ```

   

   - 객체의 멤버함수에서 객체자신의 주소를 리턴 할 때

     ```
     class sample {
      public :
        sample *f(){
         .....................
           return this;
        }
     };
     ```

     
