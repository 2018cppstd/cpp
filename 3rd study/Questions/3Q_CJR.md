chapter 3

1. template를 사용하는 이유는 무엇인지 알아보고 template를 사용하기 전에 어떠한 방식으로 그 기능을 구현하였는지 설명하시오.

    여러 형식에 같은 코드가 중복되는 상황에서 템플릿을 사용한다. 예를 들어, 함수 템플릿을 사용하여 같은 알고리즘을 여러 데이터 형식에 적용하는 함수 집합을 만들 수 있다. 클래스 템플릿을 사용하여 형식이 안전한 클래스 집합을 개발할 수도 있다.  

    사용전에는 함수 오버로딩을 사용하여 기능 구현을 하였다.

  ```
  int min( int a, int b ) {
     return ( a < b ) ? a : b;
  }
  
  long min( long a, long b ) {
     return ( a < b ) ? a : b;
  }
  
  char min( char a, char b ) {
     return ( a < b ) ? a : b;
  }
  ```

  ```
  template <class T> T min( T a, T b ) {
     return ( a < b ) ? a : b;
  }
  ```

  

2. standard template library에 대해 조사하고 설명하시오.

   이것은 알고리즘, 컨테이너 , 함수자 그리고 반복자라고 불리는 네가지의 구성 요소를 제공한다.

   - 컨테이너 : 같은 타입의 원소를 관리하는 선형적인 데이터 구조를 지원하는 클래스로, 일종의 지능화된 동적 배열이다. 원소를 추가하거나 삭제할 수 있고, 크기 변경에 따라 내부에서 메모리를 관리해서 개발자가 메모리를 직접 관리하는 부담을 줄여준다.  

   - 알고리즘 : 검색이나 정렬 같은 활동을 수행하는 알고리즘 대부분은 각각 반복자의 특정한 수준을 요구한다. 그러므로 반복자들에 의해 인터페이스를 제공받는 어떠한 컨테이너에서도 동작할 것이다.  

   - 반복자 

      5가지 종류를 구현한다.

     - input iterators : 값들의 시퀀스를 읽는데 사용
     - output iterators :  값들의 시퀀스를 쓰는데 사용
     - forward iterators : 읽어지고 쓰여지며 앞으로 움직임
     - bidirectional iterators :  forward iterator들과 같지만,  뒤로도 움직일 수 있음
     - random access iterators : 한 연산에서 어떤 수만큼이라도 자유롭게 움직일 수 있음

   - 함수자 : 함수 호출 연산자를 오버로드하는 클래스들을 포함한다. 함수자들은 연관된 함수가 파라미터화되는 행동을 허용하고 함수자와 함수 포인터 모두 함수 호출의 문법을 사용해서 유발될 수 있기 때문에, 이것들은 상응하는 파라미터가 오직 함수 호출 문맥에서만 보일 때 인자로서 교체될 수 있다. 

3. c++의 template이 다른 언어 java, c#, Typescript 등의 generic과 어떻게 다른지 비교하여 설명하시오.

    C# : 구문 수준에서 C# 제네릭은 매개 변수가 있는 형식에 대한 더 간단한 접근 방식으로, C++ 템플릿의 복잡함이 없습니다. 또한 구현 수준에서 주요 차이점은 런타임에 C# 제네릭 형식 대체가 수행되어 인스턴스화된 개체에 대해 제네릭 형식 정보가 유지된다는 점입니다.  

   JAVA : 내부적으로 제네릭을 추적하므로 모든 인스턴스화는 컴파일 / 실행시 동일한 기본 제네릭 클래스를 사용합니다. 따라서 어떻게 든 코드 변환 또는 다시 작성 프로세스입니다.  C ++ 템플릿은 템플릿이 새로운 클래스로 인스턴스화 될 때마다 복제되고 다시 컴파일됩니다.  주요 차이점은 Java 제네릭이 캡슐화된다는 것입니다. 오류는 해당 클래스가 사용 / 인스턴스화 될 때 발생하지 않고 나중에 플래그로 표시됩니다. 

4. Instantiation 이란 무엇인지 설명하시오.

   추상적인 개념인 클래스에서 실제 객체를 생성하는 것을 말한다.

   - 암시적 인스턴스화 : 템플릿의 인스턴스 코드를 생성할 때 컴파일러 결정하는 시점을 말한다.

      컴파일러가 코드 생성 시기를 결정할 수 있게 허용하는 것은 코드를 삽입할 적절한 장소를 찾아야하고, 심벌 링크의 중복 오류를 피하기 위해 반드시 하나의 인스턴스만 존재하도록 만들어야 하기 때문이다. 헤더 파일에 템플릿을 정의한 코드를 포함 시켜야한다.

   - 명시적 인스턴스화 : 컴파일러가 아닌 개발자가 코드 생성 시점을 결정하는 방식으로써, 

     보다 효율적인 코드 컴파일과 링크 시간을 얻을 수 있다.명시적 인스턴스화는 템플릿의 정의를 .cpp 파일에 작성한다. 